{
	package peg

	func debugf(format string, args ...interface{}) {
		if !strings.HasSuffix(format, "\n") {
			format = format + "\n"
		}
		//fmt.Printf(format, args...)
	}
}

Input <- _ expr:Expr EOF {
	debugf("Input: returning expr %#v", expr)
	return expr, nil
}

Expr <- e1:AndExpr {
    return e1, nil
}

AndExpr <- e1:OrExpr "AND" _ e2:Expr {
    n := newAndNode(e1.(Node), e2.(Node))
    debugf("AndExpr: building AND: %#v", n)
    return n, nil
} / e1:OrExpr {
    debugf("AndExpr: returning expr: %#v", e1)
    return e1, nil
}

OrExpr <- e1:NotExpr "OR" _ e2:Expr {
    n := newOrNode(e1.(Node), e2.(Node))
    debugf("OrExpr: building OR: %#v", n)
    return n, nil
} / e1:NotExpr {
    debugf("OrExpr: returning expr: %#v", e1)
    return e1, nil
}

NotExpr <- "NOT" _ e1:Expr {
    n := newNotNode(e1.(Node))
    debugf("NotExpr: building NOT: %#v", n)
    return n, nil
} / e1:BracedExpr {
    debugf("NotExpr: returning expr: %#v", e1)
    return e1, nil
}

BracedExpr <- "(" _ e1:Expr _ ")"_ {
    debugf("BracedExpr: returning expr: %#v", e1)
    return e1, nil
} / l:Literal _ {
    debugf("BracedExpr: returning literal: %#v", l)
    return l, nil
}

Literal <- text:Text {
	debugf(`Literal: returning text "%s"`, text.(string))
	return newTextNode(text.(string)), nil
} / quot:Quoted {
	// TODO: unquote
	debugf("Literal: returning quoted string `%s`", quot.(string))
	return newTextNode(quot.(string)), nil
} / num:Number {
	debugf("Literal: returning number %d", num.(int64))
	return newTextNode(fmt.Sprint(num.(int64))), nil
}

Text <- [a-zA-Z_][a-zA-Z0-9_'-]* {
	return string(c.text), nil
}

Quoted <- `"` [^"]* `"` {
	return string(c.text), nil
}

Number <- hexint:HexInteger {
	return hexint, nil
} / integer:Integer {
	return integer, nil
}

HexInteger <- '-'? '0' [xX] [0-9a-fA-F]+ {
	return strconv.ParseInt(string(c.text), 0, 0)
}

Integer <- '-'? [0-9]+ {
	return strconv.ParseInt(string(c.text), 10, 0)
}

_ "whitespace" <- [ \t]*

EOF <- !.

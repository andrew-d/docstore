{
	package parse

	import (
		"strconv"
	)

	func debugf(format string, args ...interface{}) {
		if !strings.HasSuffix(format, "\n") {
			format = format + "\n"
		}
		//fmt.Printf(format, args...)
	}
}

Input <- _ expr:Expr EOF {
	debugf("Input: returning expr %#v", expr)
	return expr, nil
}

Expr <- e1:AndExpr {
    return e1, nil
}

AndExpr <- e1:OrExpr "AND" _ e2:Expr {
    n := newAndNode(e1.(Node), e2.(Node))
    debugf("AndExpr: building AND: %#v", n)
    return n, nil
} / e1:OrExpr {
    debugf("AndExpr: returning expr: %#v", e1)
    return e1, nil
}

OrExpr <- e1:NotExpr "OR" _ e2:Expr {
    n := newOrNode(e1.(Node), e2.(Node))
    debugf("OrExpr: building OR: %#v", n)
    return n, nil
} / e1:NotExpr {
    debugf("OrExpr: returning expr: %#v", e1)
    return e1, nil
}

NotExpr <- "NOT" _ e1:Expr {
    n := newNotNode(e1.(Node))
    debugf("NotExpr: building NOT: %#v", n)
    return n, nil
} / e1:BracedExpr {
    debugf("NotExpr: returning expr: %#v", e1)
    return e1, nil
}

BracedExpr <- "(" _ e1:Expr _ ")"_ {
    debugf("BracedExpr: returning expr: %#v", e1)
    return e1, nil
} / f:FieldExpr _ {
    debugf("BracedExpr: returning field expr: %#v", f)
    return f, nil
}

FieldExpr <- fname:FieldName ":" lit:Literal {
	debugf("FieldExpr: returning field text: %#v / %#v", fname, lit)
	return newTextNode(fname.(string), lit.(string)), nil
} / lit:Literal {
	debugf("FieldExpr: returning bare text: %#v", lit)
	return newTextNode("", lit.(string)), nil
}

FieldName <- [a-zA-Z]+ {
	return string(c.text), nil
}

Literal <- text:Text {
	debugf(`Literal: returning text "%s"`, text.(string))
	return text.(string), nil
} / quot:Quoted {
	unquoted, err := strconv.Unquote(quot.(string))
	if err != nil {
		return nil, err
	}

	debugf("Literal: returning quoted string %#v", unquoted)
	return unquoted, nil
} / num:Number {
	debugf("Literal: returning number %d", num.(int64))
	return fmt.Sprint(num.(int64)), nil
}

Text <- [a-zA-Z_][a-zA-Z0-9_'-]* {
	return string(c.text), nil
}

Quoted <- `"` [^"]* `"` {
	return string(c.text), nil
}

Number <- hexint:HexInteger {
	return hexint, nil
} / integer:Integer {
	return integer, nil
}

HexInteger <- '-'? '0' [xX] [0-9a-fA-F]+ {
	return strconv.ParseInt(string(c.text), 0, 0)
}

Integer <- '-'? [0-9]+ {
	return strconv.ParseInt(string(c.text), 10, 0)
}

_ "whitespace" <- [ \t]*

EOF <- !.
